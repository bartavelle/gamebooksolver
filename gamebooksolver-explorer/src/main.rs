use crate::chapter::*;
use crate::mini::Equipment;
use rug::Rational;
use std::collections::HashMap;
use std::fs::File;
use std::io::BufReader;
use structopt::StructOpt;

mod chapter;
mod mini;

use mini::{
    Book, CVarState, CharacterConstant, CharacterVariable, ChoppedSolution, Item, NextStep,
};

#[derive(Debug, StructOpt)]
enum Subcommand {
    LoadChapter,
}

#[derive(Debug, StructOpt)]
#[structopt(
    name = "solutionexplorer",
    about = "Explore solutions generated by gamebooksolver."
)]
struct Opt {
    /// Path to the solution file
    #[structopt(short, long)]
    solpath: String,
    /// Alternate commands
    #[structopt(subcommand)]
    cmd: Option<Subcommand>,
}

#[derive(Debug, Clone, serde::Serialize)]
struct ChapterStats {
    items: HashMap<Equipment, Rational>,
    flags: HashMap<u32, Rational>,
    endurance: HashMap<i8, Rational>,
    transitions: HashMap<u16, Rational>,
    score: Rational,
}

impl Default for ChapterStats {
    fn default() -> Self {
        ChapterStats {
            items: HashMap::new(),
            flags: HashMap::new(),
            endurance: HashMap::new(),
            transitions: HashMap::new(),
            score: Rational::from(0),
        }
    }
}

fn mksol(
    ini: NextStep,
    sttmap: HashMap<NextStep, ChoppedSolution<NextStep>>,
) -> HashMap<u16, ChapterStats> {
    type Imap = HashMap<NextStep, HashMap<u16, ChapterStats>>;
    let mut memo: Imap = HashMap::new();

    fn go(
        curmap: &mut Imap,
        searchmap: &HashMap<NextStep, ChoppedSolution<NextStep>>,
        curns: &NextStep,
    ) -> HashMap<u16, ChapterStats> {
        if let Some(e) = curmap.get(curns) {
            return e.clone();
        }
        let src = match curns.chapter() {
            Some(cid) => cid,
            None => return HashMap::new(),
        };
        let cvar = match curns.cvar() {
            None => return HashMap::from([(src, ChapterStats::default())]),
            Some(s) => s,
        };

        // basic state
        let mut stats = ChapterStats::default();
        stats.items.insert(cvar.cequipment, Rational::from(1));
        stats.flags.insert(cvar.flags, Rational::from(1));
        stats.endurance.insert(cvar.curendurance, Rational::from(1));
        let mut out = HashMap::from([(src, stats)]);

        let cs = match searchmap.get(curns) {
            None => {
                eprintln!("Missing state!?! {:?}", curns);
                return out;
            }
            Some(x) => x,
        };

        let mut update_choice =
            |p: Rational, cstt: &NextStep, memo: &mut HashMap<u16, ChapterStats>| {
                let curmemo = go(curmap, searchmap, cstt);
                for (cid, curstats) in curmemo.into_iter() {
                    let e = memo.entry(cid).or_default();
                    for (i, ip) in curstats.items.into_iter() {
                        let ei = e.items.entry(i).or_default();
                        *ei += ip * &p;
                    }
                    for (f, ip) in curstats.flags.into_iter() {
                        let ei = e.flags.entry(f).or_default();
                        *ei += ip * &p;
                    }
                    for (en, ip) in curstats.endurance.into_iter() {
                        let ei = e.endurance.entry(en).or_default();
                        *ei += ip * &p;
                    }
                    for (dst, ip) in curstats.transitions.into_iter() {
                        let ei = e.transitions.entry(dst).or_default();
                        *ei += ip * &p;
                    }
                    e.score += curstats.score * &p;
                }

                if let Some(dst) = cstt.chapter() {
                    let e = memo.get_mut(&src).expect("there should be an entry here");
                    let e2 = e.transitions.entry(dst).or_default();
                    *e2 += &p;
                }
            };

        match cs {
            ChoppedSolution::CLeafLost => {}
            ChoppedSolution::CLeaf(sc) => {
                let e = out.get_mut(&src).expect("there should be an entry here");
                e.score = sc.clone();
            }
            ChoppedSolution::CJump(_, stt) => {
                let e = out.get_mut(&src).expect("there should be an entry here");
                e.score = Rational::from(1);
                update_choice(Rational::from(1), stt, &mut out);
            }
            ChoppedSolution::CNode(_, pms) => {
                let e = out.get_mut(&src).expect("there should be an entry here");
                e.score = Rational::from(1);
                for (mstt, p) in pms.iter() {
                    if let Some(stt) = mstt {
                        update_choice(p.clone(), stt, &mut out);
                    }
                }
            }
        }
        curmap.insert(curns.clone(), out.clone());
        out
    }

    go(&mut memo, &sttmap, &ini)
}

// fn update_score(src: u16, sc: Rational, entry: &mut Entry) {
//     entry.entry(src).and_modify(|x| x.1 = sc);
// }

// let mut update_choice =
//     |p: Rational,
//      cstt: &NextStep,
//      entry: &mut Entry,
//      winmap: &mut HashMap<CharacterVariable, Rational>| {
//         let (thisentry, curwinmap) = go(lastchapter, curmap, searchmap, cstt);
//         for (winstt, winproba) in curwinmap.into_iter() {
//             let e = winmap.entry(winstt).or_insert_with(|| Rational::from(0));
//             *e += winproba * &p;
//         }
//         for (k1, (mp, csc, cen)) in thisentry.into_iter() {
//             let e = entry
//                 .entry(k1)
//                 .or_insert_with(|| (HashMap::new(), Rational::from(0), Rational::from(0)));
//             e.1 += csc * &p;
//             e.2 += cen * &p;
//             for (k2, tscore) in mp.into_iter() {
//                 let e2 = e.0.entry(k2).or_insert_with(|| Rational::from(0));
//                 *e2 += tscore * &p;
//             }
//         }
//         if let Some(dst) = cstt.chapter() {
//             let e = entry
//                 .entry(src)
//                 .or_insert_with(|| (HashMap::new(), Rational::from(0), Rational::from(0)));
//             let e2 = e.0.entry(dst).or_insert_with(|| Rational::from(0));
//             *e2 += &p;
//         }
//     };

// match cs {
//     ChoppedSolution::CLeafLost => (),
//     ChoppedSolution::CLeaf(sc) => update_score(src, sc.clone(), &mut entry),
//     ChoppedSolution::CJump(_, stt) => {
//         update_choice(Rational::from(1), stt, &mut entry, &mut winmap);
//         update_score(src, Rational::from(1), &mut entry);
//     }
//     ChoppedSolution::CNode(_, pms) => {
//         update_score(src, Rational::from(1), &mut entry);
//         for (mstt, sc) in pms.iter() {
//             if let Some(stt) = mstt {
//                 update_choice(sc.clone(), stt, &mut entry, &mut winmap);
//             }
//         }
//     }
// }
// curmap.insert(curstt.clone(), (entry.clone(), winmap.clone()));

fn default_items(book: Book) -> Vec<(Item, i64)> {
    use mini::Weapon::{ShortSword, Sommerswerd};
    use Book::*;
    use Item::*;
    match book {
        Book01 => vec![(Weapon(ShortSword), 1), (Shield, 1)],
        Book02 => vec![(Weapon(ShortSword), 1), (GenSpecial(3), 1), (Shield, 1)],
        Book03 => vec![(Weapon(Sommerswerd), 1), (Laumspur, 1), (Meal, 1)],
        Book04 => vec![
            (Weapon(Sommerswerd), 1),
            (Laumspur, 1),
            (Meal, 4),
            (Shield, 1),
        ],
        Book05 => vec![
            (Weapon(Sommerswerd), 1),
            (Laumspur, 1),
            (Shield, 1),
            (Meal, 2),
        ],
    }
}

fn mkchar(ccst: CharacterConstant, cvar: CVarState) -> CharacterVariable {
    let mut cv = CharacterVariable::new(ccst.maxendurance);
    for (itm, qty) in cvar
        .items
        .unwrap_or_else(|| default_items(ccst.bookid))
        .into_iter()
    {
        cv.add_item(itm, qty);
    }
    cv.add_item(Item::Gold, cvar.gold as i64);
    for f in cvar.flags.into_iter() {
        cv.set_flag(f);
    }
    cv
}

fn count_states<A>(cnt: &[(NextStep, A)]) -> HashMap<u16, u64> {
    let mut o = HashMap::new();
    for (ns, _) in cnt.iter() {
        if let Some(cid) = ns.chapter() {
            let e = o.entry(cid).or_insert(0);
            *e += 1;
        }
    }
    o
}

fn decode_buffer<R: std::io::Read>(r: &mut R) -> mini::SolutionDump {
    let mut buf = Vec::new();
    r.read_to_end(&mut buf).unwrap();
    mini::parse_soldump(&buf).unwrap()
}

#[derive(serde::Serialize)]
struct Output {
    bookid: String,
    res: HashMap<u16, ChapterStats>,
    sttmap: HashMap<u16, u64>,
}

fn main() {
    let opt = Opt::from_args();

    match &opt.cmd {
        None => {
            let file = File::open(opt.solpath.clone()).unwrap();
            let mut dec = zstd::Decoder::new(file).unwrap();
            let soldump = decode_buffer(&mut dec);

            let sttmap = count_states(&soldump.content);
            let bookid = soldump.soldesc.ccst.bookid;
            let ini = NextStep::NewChapter(1, mkchar(soldump.soldesc.ccst, soldump.soldesc.cvar));
            let searchmap: HashMap<NextStep, ChoppedSolution<NextStep>> =
                soldump.content.into_iter().collect();
            eprintln!("{} : {} states", opt.solpath, searchmap.len());
            let res = mksol(ini, searchmap);
            let output = Output {
                bookid: format!("{:?}", bookid),
                res,
                sttmap,
            };
            let x = serde_json::to_string(&output).unwrap();
            println!("{}", x);
        }
        Some(Subcommand::LoadChapter) => {
            let file = File::open(opt.solpath.clone()).unwrap();
            let reader = BufReader::new(file);
            let u: Vec<(ChapterId, Chapter)> = serde_json::from_reader(reader).unwrap();
            println!("{:?}", u);
        }
    }
}
