use rug::Rational;
use std::collections::HashMap;
use std::fs::File;
use structopt::StructOpt;

mod mini;

use mini::{
    Book, CVarState, CharacterConstant, CharacterVariable, ChoppedSolution, Item, NextStep,
};

#[derive(Debug, StructOpt)]
#[structopt(
    name = "solutionexplorer",
    about = "Explore solutions generated by gamebooksolver."
)]
struct Opt {
    /// Path to the solution file
    #[structopt(short, long)]
    solpath: String,
}

fn mksol(
    ini: NextStep,
    sttmap: HashMap<NextStep, ChoppedSolution<NextStep>>,
) -> (
    HashMap<u16, HashMap<u16, Rational>>,
    HashMap<u16, (Rational, Rational)>,
) {
    let mut linkmap = HashMap::new();
    let mut scoremap = HashMap::new();
    let mut queue = vec![(Rational::from(1), ini)];

    let update_choice = |src: u16,
                         p1: &Rational,
                         dstt: &NextStep,
                         mp: &mut HashMap<u16, HashMap<u16, Rational>>| {
        if let Some(dst) = dstt.chapter() {
            let submap = mp.entry(src).or_default();
            let e = submap.entry(dst).or_default();
            *e += p1;
        }
    };
    let update_score =
        |src: u16, s1: &Rational, s2: &Rational, mp: &mut HashMap<u16, (Rational, Rational)>| {
            let e = mp.entry(src).or_default();
            e.0 += s1;
            e.1 += s2;
        };

    loop {
        let (p, s) = match queue.pop() {
            Some(x) => x,
            None => return (linkmap, scoremap),
        };
        let src = match s.chapter() {
            Some(cid) => cid,
            None => continue,
        };
        let eep = match &s {
            NextStep::HasLost(_) => Rational::from(0),
            NextStep::HasWon(_) => Rational::from(0),
            NextStep::NewChapter(_, stt) => Rational::from(stt.curendurance),
        } * &p;
        let sol = match sttmap.get(&s) {
            None => continue,
            Some(s) => s,
        };
        match sol {
            ChoppedSolution::CLeafLost => continue,
            ChoppedSolution::CLeaf(sc) => update_score(src, &(sc * p), &eep, &mut scoremap),
            ChoppedSolution::CJump(_, stt) => {
                update_choice(src, &p, stt, &mut linkmap);
                update_score(src, &p, &eep, &mut scoremap);
                queue.push((p, stt.clone()));
            }
            ChoppedSolution::CNode(_, pms) => {
                update_score(src, &p, &eep, &mut scoremap);
                for (mstt, sc) in pms.iter() {
                    if let Some(stt) = mstt {
                        let pe = sc * p.clone();
                        update_choice(src, &pe, stt, &mut linkmap);
                        queue.push((pe, stt.clone()));
                    }
                }
            }
        }
    }
}

fn default_items(book: Book) -> Vec<(Item, i64)> {
    use mini::Weapon::{ShortSword, Sommerswerd};
    use Book::*;
    use Item::*;
    match book {
        Book01 => vec![(Weapon(ShortSword), 1), (Shield, 1)],
        Book02 => vec![(Weapon(ShortSword), 1), (GenSpecial(3), 1), (Shield, 1)],
        Book03 => vec![(Weapon(Sommerswerd), 1), (Laumspur, 1), (Meal, 1)],
        Book04 => vec![
            (Weapon(Sommerswerd), 1),
            (Laumspur, 1),
            (Meal, 4),
            (Shield, 1),
        ],
        Book05 => vec![
            (Weapon(Sommerswerd), 1),
            (Laumspur, 1),
            (Shield, 1),
            (Meal, 2),
        ],
    }
}

fn mkchar(ccst: CharacterConstant, cvar: CVarState) -> CharacterVariable {
    let mut cv = CharacterVariable::new(ccst.maxendurance);
    for (itm, qty) in cvar
        .items
        .unwrap_or_else(|| default_items(ccst.bookid))
        .into_iter()
    {
        cv.add_item(itm, qty);
    }
    cv.add_item(Item::Gold, cvar.gold as i64);
    for f in cvar.flags.into_iter() {
        cv.set_flag(f);
    }
    cv
}

fn count_states<A>(cnt: &[(NextStep, A)]) -> HashMap<u16, u64> {
    let mut o = HashMap::new();
    for (ns, _) in cnt.iter() {
        if let Some(cid) = ns.chapter() {
            let e = o.entry(cid).or_insert(0);
            *e += 1;
        }
    }
    o
}

fn decode_buffer<R: std::io::Read>(r: &mut R) -> mini::SolutionDump {
    let mut buf = Vec::new();
    r.read_to_end(&mut buf).unwrap();
    mini::parse_soldump(&buf).unwrap()
}

fn main() {
    let opt = Opt::from_args();

    let file = File::open(opt.solpath).unwrap();
    let mut dec = zstd::Decoder::new(file).unwrap();

    // let mut d = cbor::Decoder::from_reader(dec);
    // let cbor = d.items().next().unwrap().unwrap();
    // let soldump = soldump_from_cbor(cbor).unwrap();

    let soldump = decode_buffer(&mut dec);

    let sttmap = count_states(&soldump.content);
    let bookid = soldump.soldesc.ccst.bookid;
    let (transitions, scores) = mksol(
        NextStep::NewChapter(1, mkchar(soldump.soldesc.ccst, soldump.soldesc.cvar)),
        soldump.content.into_iter().collect(),
    );
    let x = serde_json::to_string(&(format!("{:?}", bookid), scores, transitions, sttmap)).unwrap();
    println!("{}", x);
}
