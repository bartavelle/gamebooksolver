use crate::lonewolf::data::Multistat;
use crate::lonewolf::explore::explore_solution;
use crate::lonewolf::solve::solve_lws;
use crate::solver::base::{ChoppedSolution, SolNode};
use lonewolf::chapter::*;
use rug::Rational;
use std::collections::HashMap;
use std::collections::HashSet;
use std::fs::File;
use std::io::BufReader;
use std::io::Write;
use structopt::StructOpt;

mod lonewolf;
mod solver;

use lonewolf::mini::{
    mkchar, Book, CVarState, CharacterConstant, CharacterVariable, Discipline, Equipment, Flag,
    Flags, Item, NextStep, SolDesc, SolutionDump, Weapon,
};

#[derive(Debug, StructOpt)]
struct OSolDesc {
    #[structopt(long = "maxendurance")]
    pub maxendurance: i8,
    #[structopt(long = "skill")]
    pub combat_skill: u8,
    #[structopt(long = "discipline", short = "d")]
    pub discipline: Vec<Discipline>,
    #[structopt(long = "book")]
    pub bookid: Book,
    #[structopt(long = "item", short = "i")]
    pub items: Vec<Item>,
    #[structopt(long = "gold")]
    pub gold: u8,
    #[structopt(long = "flag", short = "f")]
    pub flags: Vec<Flag>,
    #[structopt(long = "autoweapon")]
    pub autoweapon: bool,
    #[structopt(long = "finalchapters")]
    pub finalchapters: Vec<u16>,
    #[structopt(long = "bookpath")]
    pub bookpath: String,
    #[structopt(long = "results")]
    pub resultspath: Option<String>,
}

#[derive(Debug, StructOpt)]
enum Subcommand {
    LoadChapter,
    DumpStates { cid: u16 },
    Soldump(OSolDesc),
    Explore { bookpath: String },
}

#[derive(Debug, StructOpt)]
#[structopt(
    name = "solutionexplorer",
    about = "Explore solutions generated by gamebooksolver."
)]
struct Opt {
    /// Path to the solution file
    #[structopt(short, long)]
    solpath: String,
    /// Alternate commands
    #[structopt(subcommand)]
    cmd: Option<Subcommand>,
}

#[derive(Debug, Clone, serde::Serialize)]
struct ChapterStats {
    items: HashMap<Equipment, Rational>,
    flags: HashMap<u32, Rational>,
    endurance: HashMap<i8, Rational>,
    transitions: HashMap<u16, Rational>,
    score: Rational,
}

impl Default for ChapterStats {
    fn default() -> Self {
        ChapterStats {
            items: HashMap::new(),
            flags: HashMap::new(),
            endurance: HashMap::new(),
            transitions: HashMap::new(),
            score: Rational::from(0),
        }
    }
}

fn mksol(
    ini: NextStep,
    sttmap: HashMap<NextStep, ChoppedSolution<NextStep>>,
) -> HashMap<u16, ChapterStats> {
    type Imap = HashMap<NextStep, HashMap<u16, ChapterStats>>;
    let mut memo: Imap = HashMap::new();

    fn go(
        curmap: &mut Imap,
        searchmap: &HashMap<NextStep, ChoppedSolution<NextStep>>,
        curns: &NextStep,
    ) -> HashMap<u16, ChapterStats> {
        if let Some(e) = curmap.get(curns) {
            return e.clone();
        }
        let src = match curns.chapter() {
            Some(cid) => cid,
            None => return HashMap::new(),
        };
        let cvar = match curns.cvar() {
            None => return HashMap::from([(src, ChapterStats::default())]),
            Some(s) => s,
        };

        // basic state
        let mut stats = ChapterStats::default();
        stats.items.insert(cvar.cequipment, Rational::from(1));
        stats.flags.insert(cvar.flags.0, Rational::from(1));
        stats.endurance.insert(cvar.curendurance, Rational::from(1));
        let mut out = HashMap::from([(src, stats)]);

        let cs = match searchmap.get(curns) {
            None => panic!("Missing state!?! {:?}", curns),
            Some(x) => x,
        };

        let mut update_choice =
            |p: Rational, cstt: &NextStep, memo: &mut HashMap<u16, ChapterStats>| {
                let curmemo = go(curmap, searchmap, cstt);
                for (cid, curstats) in curmemo.into_iter() {
                    let e = memo.entry(cid).or_default();
                    for (i, ip) in curstats.items.into_iter() {
                        let ei = e.items.entry(i).or_default();
                        *ei += ip * &p;
                    }
                    for (f, ip) in curstats.flags.into_iter() {
                        let ei = e.flags.entry(f).or_default();
                        *ei += ip * &p;
                    }
                    for (en, ip) in curstats.endurance.into_iter() {
                        let ei = e.endurance.entry(en).or_default();
                        *ei += ip * &p;
                    }
                    for (dst, ip) in curstats.transitions.into_iter() {
                        let ei = e.transitions.entry(dst).or_default();
                        *ei += ip * &p;
                    }
                    e.score += curstats.score * &p;
                }

                if let Some(dst) = cstt.chapter() {
                    let e = memo.get_mut(&src).expect("there should be an entry here");
                    let e2 = e.transitions.entry(dst).or_default();
                    *e2 += &p;
                }
            };

        match cs {
            ChoppedSolution::CLeafLost => {}
            ChoppedSolution::CLeaf(sc) => {
                let e = out.get_mut(&src).expect("there should be an entry here");
                e.score = sc.clone();
            }
            ChoppedSolution::CJump(_, stt) => {
                let e = out.get_mut(&src).expect("there should be an entry here");
                e.score = Rational::from(1);
                update_choice(Rational::from(1), stt, &mut out);
            }
            ChoppedSolution::CNode(_, pms) => {
                let e = out.get_mut(&src).expect("there should be an entry here");
                e.score = Rational::from(1);
                for (mstt, p) in pms.iter() {
                    if let Some(stt) = mstt {
                        update_choice(p.clone(), stt, &mut out);
                    }
                }
            }
        }
        curmap.insert(curns.clone(), out.clone());
        out
    }

    go(&mut memo, &sttmap, &ini)
}

fn count_states<A>(cnt: &[(NextStep, A)]) -> HashMap<u16, u64> {
    let mut o = HashMap::new();
    for (ns, _) in cnt.iter() {
        if let Some(cid) = ns.chapter() {
            let e = o.entry(cid).or_insert(0);
            *e += 1;
        }
    }
    o
}

fn decode_buffer<R: std::io::Read>(r: &mut R) -> lonewolf::mini::SolutionDump {
    let mut buf = Vec::new();
    r.read_to_end(&mut buf).unwrap();
    minicbor::decode(&buf).unwrap()
    // lonewolf::mini::parse_soldump(&buf).unwrap()
}

#[derive(serde::Serialize)]
struct Output {
    bookid: String,
    res: HashMap<u16, ChapterStats>,
    sttmap: HashMap<u16, u64>,
}

fn load_soldump(pth: &str) -> lonewolf::mini::SolutionDump {
    let file = File::open(pth).unwrap();
    let mut dec = zstd::Decoder::new(file).unwrap();
    decode_buffer(&mut dec)
}

fn chop_solution(sol: SolNode<NextStep>) -> ChoppedSolution<NextStep> {
    match sol {
        SolNode::Win(sc) => ChoppedSolution::CLeaf(sc),
        SolNode::Single(sc, u) => ChoppedSolution::CJump(sc, u),
        SolNode::Chosen(sc, outcome) => {
            ChoppedSolution::CNode(sc, outcome.into_iter().map(|x| (Some(x.v), x.p)).collect())
        }
    }
}

fn get_boundary(bookid: Book) -> (HashSet<Item>, HashSet<Flag>) {
    use Flag::*;
    use Item::{BodyArmor, Gold, Helmet, StrengthPotion4};

    match bookid {
        Book::Book01 => (
            [Helmet, BodyArmor, Gold].into_iter().collect(),
            HashSet::new(),
        ),
        Book::Book02 => ([Helmet, BodyArmor].into_iter().collect(), HashSet::new()),
        Book::Book03 => (
            [
                Item::Weapon(Weapon::Sommerswerd),
                Helmet,
                StrengthPotion4,
            ]
            .into_iter()
            .collect(),
            [HelmetIsSilver].into_iter().collect(),
        ),
        Book::Book04 => (
            [
                Item::Weapon(Weapon::Sommerswerd),
                Helmet,
                BodyArmor,
                StrengthPotion4,
            ]
            .into_iter()
            .collect(),
            [FoughtElix, PermanentSkillReduction2, HelmetIsSilver]
                .into_iter()
                .collect(),
        ),
        Book::Book05 => (HashSet::new(), HashSet::new()),
    }
}

fn load_results(
    disciplines: HashSet<Discipline>,
    iitems: &HashSet<Item>,
    iflags: &HashSet<Flag>,
    resdir: &str,
) -> HashMap<(Equipment, Flags), Rational> {
    let mut o = HashMap::new();
    for fpath in std::fs::read_dir(resdir).unwrap() {
        let pth = fpath.unwrap().path();
        if !pth.ends_with(".json") {
            continue;
        }
        let f = File::open(&pth).unwrap();
        let ms: Multistat = serde_json::de::from_reader(f).unwrap();
        if ms.msentries.len() != 1 {
            eprintln!("invalid amount of entries in {:?}", pth.to_str());
            continue;
        }
        let curdiscs: HashSet<Discipline> = ms.msdisciplines.into_iter().collect();
        if curdiscs.difference(&disciplines).count() > 1 {
            continue;
        }
        let mut flags = Flags(0);
        for f in ms.variable.flags.into_iter().filter(|f| iflags.contains(f)) {
            flags.set(f);
        }
        let mut items = Equipment(0);
        for (i, q) in ms
            .variable
            .items
            .iter()
            .flatten()
            .filter(|(i, _)| iitems.contains(i))
        {
            items.add_item(i, *q);
        }
        let mentry: &Rational = &ms.msentries[0].mratio;
        let oentry: &mut Rational = o.entry((items, flags)).or_default();
        if mentry.cmp(oentry) == std::cmp::Ordering::Greater {
            *oentry = mentry.clone();
        }
    }
    o
}

fn score_with(
    mscoremap: &Option<HashMap<(Equipment, Flags), Rational>>,
    iitems: &HashSet<Item>,
    iflags: &HashSet<Flag>,
    e: Equipment,
    f: Flags,
) -> Rational {
    match mscoremap {
        None => Rational::from(1),
        Some(scoremap) => {
            let mut re = Equipment(0);
            for i in iitems {
                let amount = e.get_item_count(i);
                if amount > 0 {
                    re.add_item(i, amount as i64);
                }
            }
            let mut rf = Flags(0);
            for i in iflags {
                if f.has(*i) {
                    rf.set(*i);
                }
            }
            match scoremap.get(&(re, rf)) {
                None => panic!(
                    "Could not find matching combination for {:?} {:?}",
                    e.items(),
                    f
                ),
                Some(x) => x.clone(),
            }
        }
    }
}

fn main() {
    let opt = Opt::from_args();

    match &opt.cmd {
        None => {
            let soldump = load_soldump(&opt.solpath);
            let ini = NextStep::NewChapter(1, mkchar(&soldump.soldesc.ccst, &soldump.soldesc.cvar));
            eprintln!("Starting condition: {:?} - {}", soldump.soldesc, ini);
            let sttmap = count_states(&soldump.content);
            let bookid = soldump.soldesc.ccst.bookid;
            let searchmap: HashMap<NextStep, ChoppedSolution<NextStep>> =
                soldump.content.into_iter().collect();
            eprintln!("{} : {} states", opt.solpath, searchmap.len());
            let res = mksol(ini, searchmap);
            let output = Output {
                bookid: format!("{:?}", bookid),
                res,
                sttmap,
            };
            let x = serde_json::to_string(&output).unwrap();
            println!("{}", x);
        }
        Some(Subcommand::Explore { bookpath }) => {
            let fl = File::open(&bookpath).unwrap();
            let book: Vec<(ChapterId, Chapter)> = serde_json::from_reader(fl).unwrap();
            let soldump = load_soldump(&opt.solpath);
            eprintln!("Starting condition: {:?}", soldump.soldesc);
            explore_solution(soldump, &book);
        }
        Some(Subcommand::LoadChapter) => {
            let file = File::open(opt.solpath.clone()).unwrap();
            let reader = BufReader::new(file);
            let u: Vec<(ChapterId, Chapter)> = serde_json::from_reader(reader).unwrap();
            println!("{:?}", u);
        }
        Some(Subcommand::DumpStates { cid }) => {
            let soldump = load_soldump(&opt.solpath);
            for (ns, sol) in &soldump.content {
                if ns.chapter() == Some(*cid) {
                    println!("{} -> {:?}", ns, sol);
                }
            }
        }
        Some(Subcommand::Soldump(cnt)) => {
            let (iitems, iflags) = get_boundary(cnt.bookid);
            let mscoremap = cnt.resultspath.as_ref().map(|pth| {
                load_results(
                    cnt.discipline.iter().copied().collect(),
                    &iitems,
                    &iflags,
                    pth,
                )
            });

            let ccst = CharacterConstant {
                bookid: cnt.bookid,
                combat_skill: cnt.combat_skill,
                discipline: cnt.discipline.clone(),
                maxendurance: cnt.maxendurance,
            };
            let cvar = CVarState {
                flags: cnt.flags.clone(),
                gold: cnt.gold,
                items: if cnt.items.is_empty() {
                    None
                } else {
                    let mut mp: HashMap<Item, i64> = HashMap::new();
                    for i in cnt.items.iter() {
                        let e = mp.entry(*i).or_insert(0);
                        *e += 1;
                    }
                    Some(mp.into_iter().collect())
                },
            };
            let finalchapters = if cnt.finalchapters.is_empty() {
                if ccst.bookid == Book::Book05 {
                    vec![400]
                } else {
                    vec![350]
                }
            } else {
                cnt.finalchapters.clone()
            };
            let fchapters: Vec<ChapterId> = finalchapters.iter().copied().map(ChapterId).collect();
            let soldesc = SolDesc {
                ccst,
                cvar,
                finalchapters,
            };
            let cvar = soldesc.cvariable();
            eprintln!("ini: {:?}", cvar);
            let fl = File::open(&cnt.bookpath).unwrap();
            let book: Vec<(ChapterId, Chapter)> = serde_json::from_reader(fl).unwrap();
            let sol = solve_lws(
                |e, f| score_with(&mscoremap, &iitems, &iflags, e, f),
                &fchapters,
                &book,
                &soldesc.ccst,
                &cvar,
            );
            let soldump = SolutionDump {
                soldesc,
                content: sol
                    .into_iter()
                    .map(|(ns, x)| (ns, chop_solution(x)))
                    .collect(),
            };

            // save json summary
            let json_path = opt.solpath.clone() + ".json";
            let json_file = File::create(&json_path).unwrap();
            serde_json::to_writer(json_file, &Multistat::from_soldump(&soldump)).unwrap();

            // save whole stuff
            let file = File::create(&opt.solpath).unwrap();
            let zwriter = zstd::Encoder::new(file, 3).unwrap();
            struct WW<'t>(zstd::Encoder<'t, std::fs::File>);

            impl<'t> minicbor::encode::Write for WW<'t> {
                type Error = std::io::Error;
                fn write_all(
                    &mut self,
                    buf: &[u8],
                ) -> std::result::Result<(), <Self as minicbor::encode::Write>::Error>
                {
                    self.0.write_all(buf)
                }
            }

            let mut w = WW(zwriter);

            minicbor::encode(&soldump, &mut w).unwrap();
            w.0.finish().unwrap();
        }
    }
}
