use rug::Rational;
use std::collections::HashMap;
use std::fs::File;
use structopt::StructOpt;

mod mini;

use mini::{
    Book, CVarState, CharacterConstant, CharacterVariable, ChoppedSolution, Item, NextStep,
};

#[derive(Debug, StructOpt)]
#[structopt(
    name = "solutionexplorer",
    about = "Explore solutions generated by gamebooksolver."
)]
struct Opt {
    /// Path to the solution file
    #[structopt(short, long)]
    solpath: String,
    /// Alternate algorithm
    #[structopt(short, long)]
    alternate: bool,
}

fn mksol(
    ini: NextStep,
    sttmap: HashMap<NextStep, ChoppedSolution<NextStep>>,
) -> (
    HashMap<u16, HashMap<u16, Rational>>,
    HashMap<u16, (Rational, Rational)>,
) {
    let mut linkmap = HashMap::new();
    let mut scoremap = HashMap::new();
    let mut queue = vec![(Rational::from(1), ini)];

    let update_choice = |src: u16,
                         p1: &Rational,
                         dstt: &NextStep,
                         mp: &mut HashMap<u16, HashMap<u16, Rational>>| {
        if let Some(dst) = dstt.chapter() {
            let submap = mp.entry(src).or_default();
            let e = submap.entry(dst).or_default();
            *e += p1;
        }
    };
    let update_score =
        |src: u16, s1: &Rational, s2: &Rational, mp: &mut HashMap<u16, (Rational, Rational)>| {
            let e = mp.entry(src).or_default();
            e.0 += s1;
            e.1 += s2;
        };

    loop {
        let (p, s) = match queue.pop() {
            Some(x) => x,
            None => return (linkmap, scoremap),
        };
        let src = match s.chapter() {
            Some(cid) => cid,
            None => continue,
        };
        let eep = match &s {
            NextStep::HasLost(_) => Rational::from(0),
            NextStep::HasWon(_) => Rational::from(0),
            NextStep::NewChapter(_, stt) => Rational::from(stt.curendurance),
        } * &p;
        let sol = match sttmap.get(&s) {
            None => continue,
            Some(s) => s,
        };
        match sol {
            ChoppedSolution::CLeafLost => continue,
            ChoppedSolution::CLeaf(sc) => update_score(src, &(sc * p), &eep, &mut scoremap),
            ChoppedSolution::CJump(_, stt) => {
                update_choice(src, &p, stt, &mut linkmap);
                update_score(src, &p, &eep, &mut scoremap);
                queue.push((p, stt.clone()));
            }
            ChoppedSolution::CNode(_, pms) => {
                update_score(src, &p, &eep, &mut scoremap);
                for (mstt, sc) in pms.iter() {
                    if let Some(stt) = mstt {
                        let pe = sc * p.clone();
                        update_choice(src, &pe, stt, &mut linkmap);
                        queue.push((pe, stt.clone()));
                    }
                }
            }
        }
    }
}

fn mksola(
    ini: NextStep,
    sttmap: HashMap<NextStep, ChoppedSolution<NextStep>>,
) -> (
    HashMap<u16, HashMap<u16, Rational>>,
    HashMap<u16, (Rational, Rational)>,
) {
    type ENTRY = HashMap<u16, (HashMap<u16, Rational>, Rational, Rational)>;
    type IMAP = HashMap<NextStep, ENTRY>;
    let mut memo: IMAP = HashMap::new();

    fn go(
        curmap: &mut IMAP,
        searchmap: &HashMap<NextStep, ChoppedSolution<NextStep>>,
        curstt: &NextStep,
    ) -> ENTRY {
        if let Some(e) = curmap.get(curstt) {
            return e.clone();
        }
        let cs = match searchmap.get(curstt) {
            None => return HashMap::new(),
            Some(x) => x,
        };
        let src = match curstt.chapter() {
            Some(cid) => cid,
            None => return HashMap::new(),
        };
        let ee = match &curstt {
            NextStep::HasLost(_) => Rational::from(0),
            NextStep::HasWon(_) => Rational::from(0),
            NextStep::NewChapter(_, stt) => Rational::from(stt.curendurance),
        };
        let mut entry = HashMap::new();
        entry.insert(src, (HashMap::new(), Rational::from(1), ee));

        fn update_score(src: u16, sc: Rational, entry: &mut ENTRY) {
            entry.entry(src).and_modify(|x| x.1 = sc);
        }

        fn update_choice(
            curmap: &mut IMAP,
            searchmap: &HashMap<NextStep, ChoppedSolution<NextStep>>,
            src: u16,
            p: Rational,
            cstt: &NextStep,
            entry: &mut ENTRY,
        ) {
            let thisentry = go(curmap, searchmap, cstt);
            for (k1, (mp, csc, cen)) in thisentry.into_iter() {
                let e = entry
                    .entry(k1)
                    .or_insert_with(|| (HashMap::new(), Rational::from(0), Rational::from(0)));
                e.1 += csc * &p;
                e.2 += cen * &p;
                for (k2, tscore) in mp.into_iter() {
                    let e2 = e.0.entry(k2).or_insert_with(|| Rational::from(0));
                    *e2 += tscore * &p;
                }
            }
            if let Some(dst) = cstt.chapter() {
                let e = entry
                    .entry(src)
                    .or_insert_with(|| (HashMap::new(), Rational::from(0), Rational::from(0)));
                let e2 = e.0.entry(dst).or_insert_with(|| Rational::from(0));
                *e2 += &p;
            }
        }

        match cs {
            ChoppedSolution::CLeafLost => (),
            ChoppedSolution::CLeaf(sc) => update_score(src, sc.clone(), &mut entry),
            ChoppedSolution::CJump(_, stt) => {
                update_choice(curmap, searchmap, src, Rational::from(1), stt, &mut entry);
                update_score(src, Rational::from(1), &mut entry);
            }
            ChoppedSolution::CNode(_, pms) => {
                update_score(src, Rational::from(1), &mut entry);
                for (mstt, sc) in pms.iter() {
                    if let Some(stt) = mstt {
                        update_choice(curmap, searchmap, src, sc.clone(), stt, &mut entry);
                    }
                }
            }
        }
        curmap.insert(curstt.clone(), entry.clone());
        entry
    }

    let mp = go(&mut memo, &sttmap, &ini);
    let mut transitions = HashMap::new();
    let mut scores = HashMap::new();
    for (k, (m, s1, s2)) in mp.into_iter() {
        transitions.insert(k, m);
        scores.insert(k, (s1, s2));
    }
    (transitions, scores)
}

fn default_items(book: Book) -> Vec<(Item, i64)> {
    use mini::Weapon::{ShortSword, Sommerswerd};
    use Book::*;
    use Item::*;
    match book {
        Book01 => vec![(Weapon(ShortSword), 1), (Shield, 1)],
        Book02 => vec![(Weapon(ShortSword), 1), (GenSpecial(3), 1), (Shield, 1)],
        Book03 => vec![(Weapon(Sommerswerd), 1), (Laumspur, 1), (Meal, 1)],
        Book04 => vec![
            (Weapon(Sommerswerd), 1),
            (Laumspur, 1),
            (Meal, 4),
            (Shield, 1),
        ],
        Book05 => vec![
            (Weapon(Sommerswerd), 1),
            (Laumspur, 1),
            (Shield, 1),
            (Meal, 2),
        ],
    }
}

fn mkchar(ccst: CharacterConstant, cvar: CVarState) -> CharacterVariable {
    let mut cv = CharacterVariable::new(ccst.maxendurance);
    for (itm, qty) in cvar
        .items
        .unwrap_or_else(|| default_items(ccst.bookid))
        .into_iter()
    {
        cv.add_item(itm, qty);
    }
    cv.add_item(Item::Gold, cvar.gold as i64);
    for f in cvar.flags.into_iter() {
        cv.set_flag(f);
    }
    cv
}

fn count_states<A>(cnt: &[(NextStep, A)]) -> HashMap<u16, u64> {
    let mut o = HashMap::new();
    for (ns, _) in cnt.iter() {
        if let Some(cid) = ns.chapter() {
            let e = o.entry(cid).or_insert(0);
            *e += 1;
        }
    }
    o
}

fn decode_buffer<R: std::io::Read>(r: &mut R) -> mini::SolutionDump {
    let mut buf = Vec::new();
    r.read_to_end(&mut buf).unwrap();
    mini::parse_soldump(&buf).unwrap()
}

fn main() {
    let opt = Opt::from_args();

    let file = File::open(opt.solpath.clone()).unwrap();
    let mut dec = zstd::Decoder::new(file).unwrap();
    let soldump = decode_buffer(&mut dec);

    let sttmap = count_states(&soldump.content);
    let bookid = soldump.soldesc.ccst.bookid;
    let ini = NextStep::NewChapter(1, mkchar(soldump.soldesc.ccst, soldump.soldesc.cvar));
    let searchmap: HashMap<NextStep, ChoppedSolution<NextStep>> =
        soldump.content.into_iter().collect();
    eprintln!("{} : {} states", opt.solpath, searchmap.len());
    let (transitions, scores) = if opt.alternate {
        mksola(ini, searchmap)
    } else {
        mksol(ini, searchmap)
    };
    let x = serde_json::to_string(&(format!("{:?}", bookid), scores, transitions, sttmap)).unwrap();
    println!("{}", x);
}
