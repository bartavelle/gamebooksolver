use crate::lonewolf::data::Multistat;
use crate::lonewolf::explore::explore_solution;
use crate::lonewolf::solve::solve_lws;
use crate::solver::base::optimize_outcome;
use crate::solver::base::Proba;
use crate::solver::base::{ChoppedSolution, SolNode};
use lonewolf::chapter::*;
use rug::Rational;
use std::collections::HashMap;
use std::collections::HashSet;
use std::fs::File;
use std::io::BufReader;
use std::io::Write;
use structopt::StructOpt;

mod lonewolf;
mod solver;

use lonewolf::mini::{
    mkchar, Book, CVarState, CharacterConstant, CharacterVariable, CompactSolution, CompactState,
    Discipline, Equipment, Flag, Flags, Item, NextStep, SolDesc, SolutionDump, Weapon,
};

#[derive(Debug, StructOpt)]
struct OSolDesc {
    #[structopt(long = "maxendurance")]
    pub maxendurance: i8,
    #[structopt(long = "skill")]
    pub combat_skill: u8,
    #[structopt(long = "discipline", short = "d")]
    pub discipline: Vec<Discipline>,
    #[structopt(long = "book")]
    pub bookid: Book,
    #[structopt(long = "item", short = "i")]
    pub items: Vec<Item>,
    #[structopt(long = "gold")]
    pub gold: u8,
    #[structopt(long = "flag", short = "f")]
    pub flags: Vec<Flag>,
    #[structopt(long = "autoweapon")]
    pub autoweapon: bool,
    #[structopt(long = "finalchapters")]
    pub finalchapters: Vec<u16>,
    #[structopt(long = "bookpath")]
    pub bookpath: String,
    #[structopt(long = "results")]
    pub resultspath: Option<String>,
}

#[derive(Debug, StructOpt)]
enum Subcommand {
    LoadChapter,
    DumpStates { cid: u16 },
    CompareStates { otherpath: String, cid: u16 },
    Soldump(OSolDesc),
    Explore { bookpath: String },
    Optimize { target: String },
}

#[derive(Debug, StructOpt)]
#[structopt(
    name = "solutionexplorer",
    about = "Explore solutions generated by gamebooksolver."
)]
struct Opt {
    /// Path to the solution file
    #[structopt(short, long)]
    solpath: String,
    /// Alternate commands
    #[structopt(subcommand)]
    cmd: Option<Subcommand>,
}

#[derive(Debug, Clone, serde::Serialize)]
struct ChapterStats {
    items: HashMap<Equipment, Rational>,
    flags: HashMap<u32, Rational>,
    endurance: HashMap<i8, Rational>,
    transitions: HashMap<u16, Rational>,
    score: Rational,
}

impl Default for ChapterStats {
    fn default() -> Self {
        ChapterStats {
            items: HashMap::new(),
            flags: HashMap::new(),
            endurance: HashMap::new(),
            transitions: HashMap::new(),
            score: Rational::from(0),
        }
    }
}

fn mksol(
    ini: NextStep,
    sttmap: HashMap<NextStep, ChoppedSolution<NextStep>>,
) -> HashMap<u16, ChapterStats> {
    type Imap = HashMap<NextStep, HashMap<u16, ChapterStats>>;
    let mut memo: Imap = HashMap::new();

    fn go(
        curmap: &mut Imap,
        searchmap: &HashMap<NextStep, ChoppedSolution<NextStep>>,
        curns: &NextStep,
    ) -> HashMap<u16, ChapterStats> {
        if let Some(e) = curmap.get(curns) {
            return e.clone();
        }
        let src = match curns.chapter() {
            Some(cid) => cid,
            None => return HashMap::new(),
        };
        let cvar = match curns.cvar() {
            None => return HashMap::from([(src, ChapterStats::default())]),
            Some(s) => s,
        };

        // basic state
        let mut stats = ChapterStats::default();
        stats.items.insert(cvar.cequipment, Rational::from(1));
        stats.flags.insert(cvar.flags.0, Rational::from(1));
        stats.endurance.insert(cvar.curendurance, Rational::from(1));
        let mut out = HashMap::from([(src, stats)]);

        let cs = match searchmap.get(curns) {
            None => panic!("Missing state!?! {:?}", curns),
            Some(x) => x,
        };

        let mut update_choice =
            |p: Rational, cstt: &NextStep, memo: &mut HashMap<u16, ChapterStats>| {
                let curmemo = go(curmap, searchmap, cstt);
                for (cid, curstats) in curmemo.into_iter() {
                    let e = memo.entry(cid).or_default();
                    for (i, ip) in curstats.items.into_iter() {
                        let ei = e.items.entry(i).or_default();
                        *ei += ip * &p;
                    }
                    for (f, ip) in curstats.flags.into_iter() {
                        let ei = e.flags.entry(f).or_default();
                        *ei += ip * &p;
                    }
                    for (en, ip) in curstats.endurance.into_iter() {
                        let ei = e.endurance.entry(en).or_default();
                        *ei += ip * &p;
                    }
                    for (dst, ip) in curstats.transitions.into_iter() {
                        let ei = e.transitions.entry(dst).or_default();
                        *ei += ip * &p;
                    }
                    e.score += curstats.score * &p;
                }

                if let Some(dst) = cstt.chapter() {
                    let e = memo.get_mut(&src).expect("there should be an entry here");
                    let e2 = e.transitions.entry(dst).or_default();
                    *e2 += &p;
                }
            };

        match cs {
            ChoppedSolution::CLeafLost => {}
            ChoppedSolution::CLeaf(sc) => {
                let e = out.get_mut(&src).expect("there should be an entry here");
                e.score = sc.clone();
            }
            ChoppedSolution::CJump(_, stt) => {
                let e = out.get_mut(&src).expect("there should be an entry here");
                e.score = Rational::from(1);
                update_choice(Rational::from(1), stt, &mut out);
            }
            ChoppedSolution::CNode(_, pms) => {
                let e = out.get_mut(&src).expect("there should be an entry here");
                e.score = Rational::from(1);
                for (mstt, p) in pms.iter() {
                    if let Some(stt) = mstt {
                        update_choice(p.clone(), stt, &mut out);
                    }
                }
            }
        }
        curmap.insert(curns.clone(), out.clone());
        out
    }

    go(&mut memo, &sttmap, &ini)
}

fn count_states<A>(cnt: &[(NextStep, A)]) -> HashMap<u16, u64> {
    let mut o = HashMap::new();
    for (ns, _) in cnt.iter() {
        if let Some(cid) = ns.chapter() {
            let e = o.entry(cid).or_insert(0);
            *e += 1;
        }
    }
    o
}

fn decode_buffer<R: std::io::Read>(r: &mut R) -> lonewolf::mini::SolutionDump {
    let mut buf = Vec::new();
    r.read_to_end(&mut buf).unwrap();
    minicbor::decode(&buf).unwrap()
    // lonewolf::mini::parse_soldump(&buf).unwrap()
}

#[derive(serde::Serialize)]
struct Output {
    bookid: String,
    res: HashMap<u16, ChapterStats>,
    sttmap: HashMap<u16, u64>,
}

fn load_soldump(pth: &str) -> lonewolf::mini::SolutionDump {
    let file = File::open(pth).unwrap();
    let mut dec = zstd::Decoder::new(file).unwrap();
    decode_buffer(&mut dec)
}

fn chop_solution(sol: SolNode<NextStep>) -> ChoppedSolution<NextStep> {
    match sol {
        SolNode::Win(sc) => ChoppedSolution::CLeaf(sc),
        SolNode::Single(sc, u) => ChoppedSolution::CJump(sc, u),
        SolNode::Chosen(sc, outcome) => {
            ChoppedSolution::CNode(sc, outcome.into_iter().map(|x| (Some(x.v), x.p)).collect())
        }
    }
}

fn get_boundary(bookid: Book) -> (HashSet<Item>, HashSet<Flag>) {
    use Flag::*;
    use Item::{BodyArmor, Gold, Helmet, StrengthPotion4};

    match bookid {
        Book::Book01 => (
            [Helmet, BodyArmor, Gold].into_iter().collect(),
            HashSet::new(),
        ),
        Book::Book02 => ([Helmet, BodyArmor].into_iter().collect(), HashSet::new()),
        Book::Book03 => (
            [Item::Weapon(Weapon::Sommerswerd), Helmet, StrengthPotion4]
                .into_iter()
                .collect(),
            [HelmetIsSilver].into_iter().collect(),
        ),
        Book::Book04 => (
            [
                Item::Weapon(Weapon::Sommerswerd),
                Helmet,
                BodyArmor,
                StrengthPotion4,
            ]
            .into_iter()
            .collect(),
            [FoughtElix, PermanentSkillReduction2, HelmetIsSilver]
                .into_iter()
                .collect(),
        ),
        Book::Book05 => (HashSet::new(), HashSet::new()),
    }
}

fn load_results(
    disciplines: HashSet<Discipline>,
    iitems: &HashSet<Item>,
    iflags: &HashSet<Flag>,
    resdir: &str,
) -> HashMap<(Equipment, Flags), Rational> {
    let mut o = HashMap::new();
    for fpath in std::fs::read_dir(resdir).unwrap() {
        let rpath = fpath.unwrap().path();
        let pth = rpath.to_str().unwrap();
        if !pth.ends_with(".json") {
            continue;
        }
        let f = File::open(&pth).unwrap();
        let ms: Multistat = serde_json::de::from_reader(f).unwrap();
        if ms.msentries.len() != 1 {
            eprintln!("invalid amount of entries in {}", pth);
            continue;
        }
        let curdiscs: HashSet<Discipline> = ms.msdisciplines.into_iter().collect();
        if curdiscs.difference(&disciplines).count() > 1 {
            continue;
        }
        let mut flags = Flags(0);
        for f in ms.variable.flags.into_iter().filter(|f| iflags.contains(f)) {
            flags.set(f);
        }
        let mut items = Equipment(0);
        for (i, q) in ms
            .variable
            .items
            .iter()
            .flatten()
            .filter(|(i, _)| iitems.contains(i))
        {
            items.add_item(i, *q);
        }
        if iitems.contains(&Item::Gold) {
            items.add_item(&Item::Gold, ms.variable.gold as i64);
        }
        let mentry: &Rational = &ms.msentries[0].mratio;
        let oentry: &mut Rational = o.entry((items, flags)).or_default();
        if mentry.cmp(oentry) == std::cmp::Ordering::Greater {
            *oentry = mentry.clone();
        }
    }
    o
}

fn score_with(
    bookid: Book,
    mscoremap: &Option<HashMap<(Equipment, Flags), Rational>>,
    iitems: &HashSet<Item>,
    iflags: &HashSet<Flag>,
    e: Equipment,
    f: Flags,
) -> Rational {
    match mscoremap {
        None => Rational::from(1),
        Some(scoremap) => {
            let mut re = Equipment(0);
            for i in iitems {
                let ramount = e.get_item_count(i);
                let amount = if i == &Item::Gold {
                    match bookid {
                        Book::Book04 => {
                            if ramount < 4 {
                                0
                            } else {
                                15
                            }
                        }
                        _ => ramount,
                    }
                } else {
                    ramount
                };
                if amount > 0 {
                    re.add_item(i, amount as i64);
                }
            }
            let mut rf = Flags(0);
            for i in iflags {
                if f.has(*i) {
                    rf.set(*i);
                }
            }
            match scoremap.get(&(re, rf)) {
                None => {
                    eprintln!(
                        "Could not find matching combination for {:?} {:?}",
                        re.items(),
                        rf
                    );
                    eprintln!("know combinations are:");
                    for (ke, kf) in scoremap.keys() {
                        eprintln!(" * {:?} {:?}", ke.items(), kf);
                    }
                    panic!("failed :(");
                }
                Some(x) => x.clone(),
            }
        }
    }
}

fn compare_sols(
    m1: HashMap<NextStep, ChoppedSolution<NextStep>>,
    m2: HashMap<NextStep, ChoppedSolution<NextStep>>,
) {
    type Ocs = Vec<(Rational, NextStep)>;
    fn deloss(chapter: Option<u16>, ns: NextStep) -> NextStep {
        match &ns {
            NextStep::NewChapter(cid, cvar) => {
                if cvar.curendurance <= 0 {
                    NextStep::HasLost(chapter.unwrap_or(*cid))
                } else {
                    ns
                }
            }
            _ => ns,
        }
    }
    fn descored(chapter: Option<u16>, cs: ChoppedSolution<NextStep>) -> Ocs {
        match cs {
            ChoppedSolution::CJump(_, ns) => vec![(Rational::from(1), deloss(chapter, ns.clone()))],
            ChoppedSolution::CNode(_, subs) => {
                let po: Vec<Proba<NextStep>> = subs
                    .into_iter()
                    .filter_map(|(ms, p)| {
                        ms.map(|s| Proba {
                            p,
                            v: deloss(chapter, s),
                        })
                    })
                    .collect();
                let mut o = optimize_outcome(po)
                    .into_iter()
                    .map(|p| (p.p, p.v))
                    .collect::<Vec<_>>();
                o.sort();
                o
            }
            _ => Vec::new(),
        }
    }

    fn pretty_outcomes(outcomes: &[(Rational, NextStep)]) {
        for (s, p) in outcomes {
            println!(" - {} {}", p, s);
        }
    }

    fn pretty_step(ns: &NextStep, outcomes: &[(Rational, NextStep)]) {
        println!("{}", ns);
        pretty_outcomes(outcomes);
    }

    let mkmap = |m: HashMap<NextStep, ChoppedSolution<NextStep>>| -> HashMap<NextStep, Ocs> {
        m.into_iter()
            .map(|(ns, cs)| {
                let ch = ns.chapter();
                (ns, descored(ch, cs))
            })
            .collect()
    };

    let m1_ = mkmap(m1);
    let m2_ = mkmap(m2);

    let mut only1: Vec<(NextStep, Ocs)> = Vec::new();
    let mut only2: Vec<(NextStep, Ocs)> = Vec::new();
    let mut differing: Vec<(NextStep, Ocs, Ocs)> = Vec::new();

    for (k1, v1) in m1_.iter() {
        match m2_.get(k1) {
            None => only1.push((k1.clone(), v1.clone())),
            Some(v2) => {
                if v1 != v2 {
                    differing.push((k1.clone(), v1.clone(), v2.clone()));
                }
            }
        }
    }
    for (k2, v2) in m2_ {
        if !m1_.contains_key(&k2) {
            only2.push((k2, v2));
        }
    }

    if !only1.is_empty() {
        println!("*** ONLY IN 1 ***");
        for (ns, outcomes) in only1.iter() {
            pretty_step(ns, outcomes);
        }
    }
    if !only2.is_empty() {
        println!("*** ONLY IN 2 ***");
        for (ns, outcomes) in only2.iter() {
            pretty_step(ns, outcomes);
        }
    }
    if !differing.is_empty() {
        println!("*** DIFF ***");
        for (k, v1, v2) in differing.iter() {
            println!("**** {} ****", k);
            pretty_outcomes(v1);
            println!("****");
            pretty_outcomes(v2);
        }
    }
}

fn diff_cvar(prev: &CharacterVariable, next: &CharacterVariable) -> String {
    let mut o: Vec<String> = Vec::new();
    match prev.curendurance.cmp(&next.curendurance) {
        std::cmp::Ordering::Greater => {
            o.push(format!("-{}hp", prev.curendurance - next.curendurance));
        }
        std::cmp::Ordering::Less => {
            o.push(format!("+{}hp", next.curendurance - prev.curendurance));
        }
        _ => (),
    }
    for i in &Item::VALUES {
        let pq = prev.cequipment.get_item_count(i);
        let nq = next.cequipment.get_item_count(i);
        match pq.cmp(&nq) {
            std::cmp::Ordering::Greater => {
                let desc = if pq - nq == 1 {
                    format!("-{:?}", i)
                } else {
                    format!("-{}{:?}", pq - nq, i)
                };
                o.push(desc);
            }
            std::cmp::Ordering::Less => {
                let desc = if nq - pq == 1 {
                    format!("+{:?}", i)
                } else {
                    format!("+{}{:?}", nq - pq, i)
                };
                o.push(desc);
            }
            _ => (),
        }
    }
    for f in &Flag::VALUES {
        if prev.flags.has(*f) && !next.flags.has(*f) {
            o.push(format!("-{:?}", f));
        }
        if !prev.flags.has(*f) && next.flags.has(*f) {
            o.push(format!("+{:?}", f));
        }
    }
    o.join(" ")
}

struct WW<I>(I);

impl<I: Write> minicbor::encode::Write for WW<I> {
    type Error = std::io::Error;
    fn write_all(
        &mut self,
        buf: &[u8],
    ) -> std::result::Result<(), <Self as minicbor::encode::Write>::Error> {
        self.0.write_all(buf)
    }
}

fn main() {
    let opt = Opt::from_args();

    match &opt.cmd {
        None => {
            let soldump = load_soldump(&opt.solpath);
            let ini = NextStep::NewChapter(1, mkchar(&soldump.soldesc.ccst, &soldump.soldesc.cvar));
            eprintln!("Starting condition: {:?} - {}", soldump.soldesc, ini);
            let sttmap = count_states(&soldump.content);
            let bookid = soldump.soldesc.ccst.bookid;
            let searchmap: HashMap<NextStep, ChoppedSolution<NextStep>> =
                soldump.content.into_iter().collect();
            eprintln!("{} : {} states", opt.solpath, searchmap.len());
            let res = mksol(ini, searchmap);
            let output = Output {
                bookid: format!("{:?}", bookid),
                res,
                sttmap,
            };
            let x = serde_json::to_string(&output).unwrap();
            println!("{}", x);
        }
        Some(Subcommand::Optimize { target }) => {
            let soldump = load_soldump(&opt.solpath);
            let mut content = soldump
                .content
                .into_iter()
                .filter_map(|(k, v)| CompactState::from_choppedsolution(k, v))
                .collect::<Vec<_>>();
            content.sort_by(|a, b| a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Equal));
            let compact = CompactSolution {
                soldesc: soldump.soldesc,
                content,
            };
            // save json recap
            let jname = target.clone() + ".desc";
            let json_file = File::create(&jname).unwrap();
            let mut json_w = WW(json_file);
            minicbor::encode(&compact.soldesc, &mut json_w).unwrap();

            // save compact solution
            let file = File::create(target).unwrap();
            let zwriter = zstd::Encoder::new(file, 9).unwrap();
            let mut w = WW(zwriter);
            minicbor::encode(&compact, &mut w).unwrap();
            w.0.finish().unwrap();
        }
        Some(Subcommand::Explore { bookpath }) => {
            let fl = File::open(&bookpath).unwrap();
            let book: Vec<(ChapterId, Chapter)> = serde_json::from_reader(fl).unwrap();
            let soldump = load_soldump(&opt.solpath);
            eprintln!("Starting condition: {:?}", soldump.soldesc);
            explore_solution(soldump, &book);
        }
        Some(Subcommand::LoadChapter) => {
            let file = File::open(opt.solpath.clone()).unwrap();
            let reader = BufReader::new(file);
            let u: Vec<(ChapterId, Chapter)> = serde_json::from_reader(reader).unwrap();
            println!("{:?}", u);
        }
        Some(Subcommand::DumpStates { cid }) => {
            let soldump = load_soldump(&opt.solpath);
            for (ns, sol) in &soldump.content {
                if ns.chapter() == Some(*cid) {
                    match (ns, sol) {
                        (
                            NextStep::NewChapter(_, pcvar),
                            ChoppedSolution::CJump(sc, NextStep::NewChapter(nid, ncvar)),
                        ) => println!(
                            "{} -> JUMP {:.2}% ch:{} {}",
                            ns,
                            sc.to_f64() * 100.0,
                            nid,
                            &diff_cvar(pcvar, ncvar)
                        ),
                        (NextStep::NewChapter(_, pcvar), ChoppedSolution::CNode(sc, outcomes)) => {
                            println!("{} - {:.2}% ", ns, sc.to_f64() * 100.0);
                            for (mns, pb) in outcomes {
                                match mns {
                                    Some(NextStep::NewChapter(nid, ncvar)) => {
                                        println!(
                                            " [{:.2}%] ch:{} {}",
                                            pb.to_f64() * 100.0,
                                            nid,
                                            &diff_cvar(pcvar, ncvar)
                                        )
                                    }
                                    _ => println!(" [{:.2}%] {:?}", pb.to_f64() * 100.0, mns),
                                }
                            }
                        }
                        _ => println!("{} -> {:?}", ns, sol),
                    }
                }
            }
        }
        Some(Subcommand::CompareStates { cid, otherpath }) => {
            let dump1 = load_soldump(&opt.solpath);
            println!("S1: {:?}", dump1.soldesc);
            let sols1: HashMap<NextStep, ChoppedSolution<NextStep>> = dump1
                .content
                .into_iter()
                .filter(|(ns, _)| ns.chapter() == Some(*cid))
                .collect();
            let dump2 = load_soldump(otherpath);
            println!("S2: {:?}", dump2.soldesc);
            let sols2: HashMap<NextStep, ChoppedSolution<NextStep>> = dump2
                .content
                .into_iter()
                .filter(|(ns, _)| ns.chapter() == Some(*cid))
                .collect();
            compare_sols(sols1, sols2)
        }
        Some(Subcommand::Soldump(cnt)) => {
            let (iitems, iflags) = get_boundary(cnt.bookid);
            let mscoremap = cnt.resultspath.as_ref().map(|pth| {
                load_results(
                    cnt.discipline.iter().copied().collect(),
                    &iitems,
                    &iflags,
                    pth,
                )
            });

            let ccst = CharacterConstant {
                bookid: cnt.bookid,
                combat_skill: cnt.combat_skill,
                discipline: cnt.discipline.clone(),
                maxendurance: cnt.maxendurance,
            };
            let cvar = CVarState {
                flags: cnt.flags.clone(),
                gold: cnt.gold,
                items: if cnt.items.is_empty() {
                    None
                } else {
                    let mut mp: HashMap<Item, i64> = HashMap::new();
                    for i in cnt.items.iter() {
                        let e = mp.entry(*i).or_insert(0);
                        *e += 1;
                    }
                    Some(mp.into_iter().collect())
                },
            };
            let finalchapters = if cnt.finalchapters.is_empty() {
                if ccst.bookid == Book::Book05 {
                    vec![400]
                } else {
                    vec![350]
                }
            } else {
                cnt.finalchapters.clone()
            };
            let fchapters: Vec<ChapterId> = finalchapters.iter().copied().map(ChapterId).collect();
            let soldesc = SolDesc {
                ccst,
                cvar,
                finalchapters,
            };
            let cvar = soldesc.cvariable();
            eprintln!("ini: {:?}", cvar);
            let fl = File::open(&cnt.bookpath).unwrap();
            let book: Vec<(ChapterId, Chapter)> = serde_json::from_reader(fl).unwrap();
            let sol = solve_lws(
                |e, f| score_with(soldesc.ccst.bookid, &mscoremap, &iitems, &iflags, e, f),
                &fchapters,
                &book,
                &soldesc.ccst,
                &cvar,
            );
            let soldump = SolutionDump {
                soldesc,
                content: sol
                    .into_iter()
                    .map(|(ns, x)| (ns, chop_solution(x)))
                    .collect(),
            };

            // save json summary
            let json_path = opt.solpath.clone() + ".json";
            let json_file = File::create(&json_path).unwrap();
            serde_json::to_writer(json_file, &Multistat::from_soldump(&soldump)).unwrap();

            // save whole stuff
            let file = File::create(&opt.solpath).unwrap();
            let zwriter = zstd::Encoder::new(file, 3).unwrap();
            let mut w = WW(zwriter);

            minicbor::encode(&soldump, &mut w).unwrap();
            w.0.finish().unwrap();
        }
    }
}
