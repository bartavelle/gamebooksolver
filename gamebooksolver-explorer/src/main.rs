use lonewolf::chapter::*;
use rug::Rational;
use std::collections::HashMap;
use std::fs::File;
use std::io::BufReader;
use structopt::StructOpt;

mod lonewolf;
mod solver;

use lonewolf::mini::{
    Book, CVarState, CharacterConstant, CharacterVariable, ChoppedSolution, Equipment, Item,
    NextStep,
};

#[derive(Debug, StructOpt)]
enum Subcommand {
    LoadChapter,
    DumpStates { cid: u16 },
}

#[derive(Debug, StructOpt)]
#[structopt(
    name = "solutionexplorer",
    about = "Explore solutions generated by gamebooksolver."
)]
struct Opt {
    /// Path to the solution file
    #[structopt(short, long)]
    solpath: String,
    /// Alternate commands
    #[structopt(subcommand)]
    cmd: Option<Subcommand>,
}

#[derive(Debug, Clone, serde::Serialize)]
struct ChapterStats {
    items: HashMap<Equipment, Rational>,
    flags: HashMap<u32, Rational>,
    endurance: HashMap<i8, Rational>,
    transitions: HashMap<u16, Rational>,
    score: Rational,
}

impl Default for ChapterStats {
    fn default() -> Self {
        ChapterStats {
            items: HashMap::new(),
            flags: HashMap::new(),
            endurance: HashMap::new(),
            transitions: HashMap::new(),
            score: Rational::from(0),
        }
    }
}

fn mksol(
    ini: NextStep,
    sttmap: HashMap<NextStep, ChoppedSolution<NextStep>>,
) -> HashMap<u16, ChapterStats> {
    type Imap = HashMap<NextStep, HashMap<u16, ChapterStats>>;
    let mut memo: Imap = HashMap::new();

    fn go(
        curmap: &mut Imap,
        searchmap: &HashMap<NextStep, ChoppedSolution<NextStep>>,
        curns: &NextStep,
    ) -> HashMap<u16, ChapterStats> {
        if let Some(e) = curmap.get(curns) {
            return e.clone();
        }
        let src = match curns.chapter() {
            Some(cid) => cid,
            None => return HashMap::new(),
        };
        let cvar = match curns.cvar() {
            None => return HashMap::from([(src, ChapterStats::default())]),
            Some(s) => s,
        };

        // basic state
        let mut stats = ChapterStats::default();
        stats.items.insert(cvar.cequipment, Rational::from(1));
        stats.flags.insert(cvar.flags.0, Rational::from(1));
        stats.endurance.insert(cvar.curendurance, Rational::from(1));
        let mut out = HashMap::from([(src, stats)]);

        let cs = match searchmap.get(curns) {
            None => panic!("Missing state!?! {:?}", curns),
            Some(x) => x,
        };

        let mut update_choice =
            |p: Rational, cstt: &NextStep, memo: &mut HashMap<u16, ChapterStats>| {
                let curmemo = go(curmap, searchmap, cstt);
                for (cid, curstats) in curmemo.into_iter() {
                    let e = memo.entry(cid).or_default();
                    for (i, ip) in curstats.items.into_iter() {
                        let ei = e.items.entry(i).or_default();
                        *ei += ip * &p;
                    }
                    for (f, ip) in curstats.flags.into_iter() {
                        let ei = e.flags.entry(f).or_default();
                        *ei += ip * &p;
                    }
                    for (en, ip) in curstats.endurance.into_iter() {
                        let ei = e.endurance.entry(en).or_default();
                        *ei += ip * &p;
                    }
                    for (dst, ip) in curstats.transitions.into_iter() {
                        let ei = e.transitions.entry(dst).or_default();
                        *ei += ip * &p;
                    }
                    e.score += curstats.score * &p;
                }

                if let Some(dst) = cstt.chapter() {
                    let e = memo.get_mut(&src).expect("there should be an entry here");
                    let e2 = e.transitions.entry(dst).or_default();
                    *e2 += &p;
                }
            };

        match cs {
            ChoppedSolution::CLeafLost => {}
            ChoppedSolution::CLeaf(sc) => {
                let e = out.get_mut(&src).expect("there should be an entry here");
                e.score = sc.clone();
            }
            ChoppedSolution::CJump(_, stt) => {
                let e = out.get_mut(&src).expect("there should be an entry here");
                e.score = Rational::from(1);
                update_choice(Rational::from(1), stt, &mut out);
            }
            ChoppedSolution::CNode(_, pms) => {
                let e = out.get_mut(&src).expect("there should be an entry here");
                e.score = Rational::from(1);
                for (mstt, p) in pms.iter() {
                    if let Some(stt) = mstt {
                        update_choice(p.clone(), stt, &mut out);
                    }
                }
            }
        }
        curmap.insert(curns.clone(), out.clone());
        out
    }

    go(&mut memo, &sttmap, &ini)
}

fn default_items(book: Book) -> Vec<(Item, i64)> {
    use lonewolf::mini::Weapon::{ShortSword, Sommerswerd};
    use Book::*;
    use Item::*;
    match book {
        Book01 => vec![(Weapon(ShortSword), 1), (Shield, 1)],
        Book02 => vec![(Weapon(ShortSword), 1), (GenSpecial(3), 1), (Shield, 1)],
        Book03 => vec![(Weapon(Sommerswerd), 1), (Laumspur, 1), (Meal, 1)],
        Book04 => vec![
            (Weapon(Sommerswerd), 1),
            (Laumspur, 1),
            (Meal, 4),
            (Shield, 1),
        ],
        Book05 => vec![
            (Weapon(Sommerswerd), 1),
            (Laumspur, 1),
            (Shield, 1),
            (Meal, 2),
        ],
    }
}

fn mkchar(ccst: CharacterConstant, cvar: CVarState) -> CharacterVariable {
    let mut cv = CharacterVariable::new(ccst.maxendurance);
    for (itm, qty) in cvar
        .items
        .unwrap_or_else(|| default_items(ccst.bookid))
        .into_iter()
    {
        cv.add_item(&itm, qty);
    }
    cv.add_item(&Item::Gold, cvar.gold as i64);
    for f in cvar.flags.into_iter() {
        cv.set_flag(f);
    }
    if cv.cequipment.has_itemb(&Item::BodyArmor) {
        cv.curendurance += 4;
    }
    cv
}

fn count_states<A>(cnt: &[(NextStep, A)]) -> HashMap<u16, u64> {
    let mut o = HashMap::new();
    for (ns, _) in cnt.iter() {
        if let Some(cid) = ns.chapter() {
            let e = o.entry(cid).or_insert(0);
            *e += 1;
        }
    }
    o
}

fn decode_buffer<R: std::io::Read>(r: &mut R) -> lonewolf::mini::SolutionDump {
    let mut buf = Vec::new();
    r.read_to_end(&mut buf).unwrap();
    lonewolf::mini::parse_soldump(&buf).unwrap()
}

#[derive(serde::Serialize)]
struct Output {
    bookid: String,
    res: HashMap<u16, ChapterStats>,
    sttmap: HashMap<u16, u64>,
}

fn load_soldump(pth: &str) -> lonewolf::mini::SolutionDump {
    let file = File::open(pth).unwrap();
    let mut dec = zstd::Decoder::new(file).unwrap();
    decode_buffer(&mut dec)
}

fn main() {
    let opt = Opt::from_args();

    match &opt.cmd {
        None => {
            let soldump = load_soldump(&opt.solpath);
            let sttmap = count_states(&soldump.content);
            let bookid = soldump.soldesc.ccst.bookid;
            let ini = NextStep::NewChapter(1, mkchar(soldump.soldesc.ccst, soldump.soldesc.cvar));
            let searchmap: HashMap<NextStep, ChoppedSolution<NextStep>> =
                soldump.content.into_iter().collect();
            eprintln!("{} : {} states", opt.solpath, searchmap.len());
            let res = mksol(ini, searchmap);
            let output = Output {
                bookid: format!("{:?}", bookid),
                res,
                sttmap,
            };
            let x = serde_json::to_string(&output).unwrap();
            println!("{}", x);
        }
        Some(Subcommand::LoadChapter) => {
            let file = File::open(opt.solpath.clone()).unwrap();
            let reader = BufReader::new(file);
            let u: Vec<(ChapterId, Chapter)> = serde_json::from_reader(reader).unwrap();
            println!("{:?}", u);
        }
        Some(Subcommand::DumpStates { cid }) => {
            let soldump = load_soldump(&opt.solpath);
            for (ns, sol) in &soldump.content {
                if ns.chapter() == Some(*cid) {
                    println!("{:?}", ns);
                    println!(" -> {:?}", sol);
                }
            }
        }
    }
}
